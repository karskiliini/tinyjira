<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sprint Board</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f4f5f7;
  --header-bg: #1a1a2e;
  --col-bg: #ebecf0;
  --card-bg: #fff;
  --text: #172b4d;
  --text-light: #5e6c84;
  --accent: #0052cc;
  --high: #ef5350;
  --medium: #ffa726;
  --low: #66bb6a;
  --shadow: 0 1px 3px rgba(0,0,0,0.12);
  --radius: 6px;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Header */
.header {
  background: var(--header-bg);
  color: #fff;
  padding: 14px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
}

.header h1 {
  font-size: 18px;
  font-weight: 600;
  white-space: nowrap;
}

.sprint-meta {
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 13px;
  color: #a0a0b8;
}

.sprint-meta span { white-space: nowrap; }

.progress-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
}

.progress-bar {
  width: 160px;
  height: 8px;
  background: #333;
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: var(--low);
  border-radius: 4px;
  transition: width 0.3s;
}

.progress-text {
  font-size: 13px;
  color: #a0a0b8;
  white-space: nowrap;
}

.header-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.header-controls input[type="text"] {
  padding: 6px 10px;
  border: 1px solid #444;
  border-radius: var(--radius);
  background: #2a2a40;
  color: #fff;
  font-size: 13px;
  width: 180px;
}

.header-controls input[type="text"]::placeholder { color: #777; }

.btn {
  padding: 6px 14px;
  border: none;
  border-radius: var(--radius);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}

.btn-primary { background: var(--accent); color: #fff; }
.btn-primary:hover { background: #0065ff; }
.btn-secondary { background: #ddd; color: var(--text); }
.btn-secondary:hover { background: #ccc; }
.btn-danger { background: var(--high); color: #fff; }
.btn-danger:hover { background: #d32f2f; }

/* View toggle */
.view-toggle {
  display: flex;
  background: #2a2a40;
  border-radius: var(--radius);
  overflow: hidden;
}

.view-toggle button {
  padding: 6px 14px;
  border: none;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  background: transparent;
  color: #999;
  transition: background 0.15s, color 0.15s;
}

.view-toggle button.active {
  background: var(--accent);
  color: #fff;
}

.view-toggle button:hover:not(.active) {
  background: #3a3a55;
  color: #ccc;
}

/* Layout */
.app-body {
  flex: 1;
  overflow: hidden;
}

/* Board */
.board {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  padding: 16px;
  height: 100%;
  overflow-x: auto;
}

.board.hidden { display: none; }

.column {
  background: var(--col-bg);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  min-height: 200px;
}

.column-header {
  padding: 12px 14px;
  font-weight: 600;
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-light);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.column-header .count {
  background: #ccc;
  color: #555;
  border-radius: 10px;
  padding: 1px 8px;
  font-size: 12px;
  font-weight: 600;
}

.column-body {
  flex: 1;
  padding: 0 8px 8px;
  overflow-y: auto;
  min-height: 60px;
}

.column-body.drag-over {
  background: rgba(0, 82, 204, 0.08);
  border-radius: 0 0 8px 8px;
}

/* Backlog view */
.backlog-view {
  display: none;
  height: 100%;
  overflow-y: auto;
  padding: 16px 24px 16px 60px;
}

.backlog-view.active {
  display: block;
}

.backlog-toolbar {
  display: flex;
  justify-content: flex-end;
  margin-bottom: 12px;
}

.btn-replan {
  padding: 7px 16px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: var(--radius);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}

.btn-replan:hover {
  background: #0065ff;
}

.sprint-section {
  background: var(--col-bg);
  border-radius: 8px;
  margin-bottom: 16px;
}

.sprint-section-header {
  padding: 14px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

.sprint-section-header h3 {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
}

.sprint-section-header .sprint-dates {
  font-size: 12px;
  color: var(--text-light);
  margin-left: 12px;
}

.sprint-section-header .sprint-count {
  background: #ccc;
  color: #555;
  border-radius: 10px;
  padding: 2px 10px;
  font-size: 12px;
  font-weight: 600;
}

.sprint-capacity {
  display: inline-flex;
  gap: 10px;
  margin-left: 14px;
  align-items: center;
}

.sprint-member-cap {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  font-size: 11px;
  color: var(--text-light);
  font-weight: 400;
}

.sprint-member-cap .member-label {
  font-weight: 500;
  color: var(--text);
}

.sprint-member-cap input {
  width: 36px;
  padding: 1px 4px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 11px;
  text-align: center;
  font-family: inherit;
  background: #fafafa;
}

.sprint-member-cap input:focus {
  outline: none;
  border-color: var(--accent);
  background: #fff;
}

.sprint-section-body {
  padding: 0 12px 12px;
  min-height: 40px;
}

.sprint-section-body.drag-over {
  background: rgba(0, 82, 204, 0.08);
  border-radius: 0 0 8px 8px;
}

.card-placeholder {
  background: rgba(0, 82, 204, 0.08);
  border: 2px dashed rgba(0, 82, 204, 0.25);
  border-radius: var(--radius);
  margin-bottom: 6px;
  transition: height 0.2s ease;
}

.card.drag-collapse {
  height: 0 !important;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  margin-bottom: 0 !important;
  border-width: 0 !important;
  overflow: hidden;
  opacity: 0;
  box-shadow: none !important;
}

/* Cards */
.card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 10px 12px;
  margin-bottom: 6px;
  box-shadow: var(--shadow);
  cursor: grab;
  border-left: 4px solid #ccc;
  transition: box-shadow 0.15s, transform 0.1s;
  position: relative;
}

.card.flip-animate {
  transition: transform 0.2s ease;
}

.card:hover:not(.flip-animate) {
  box-shadow: 0 0 16px rgba(0,0,0,0.25);
  transform: translateY(-1px);
  z-index: 1;
}

.backlog-view .card:hover:not(.flip-animate):not(.dragging) {
  box-shadow: 0 0 16px rgba(0,0,0,0.75);
  transform: scale(1.01, 1.12);
  transform-origin: left center;
  transform: translateX(-100);
}

.card.dragging {
  opacity: 0.5;
  transform: rotate(2deg);
}

.card.priority-high { border-left-color: var(--high); }
.card.priority-medium { border-left-color: var(--medium); }
.card.priority-low { border-left-color: var(--low); }

.backlog-view .card.status-done {
  background: #e0e0e0;
  transform: scale(0.98, 0.98);
}

.backlog-view .card.status-done .card-title {
  text-decoration: line-through;
}

.card-key {
  font-size: 11px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 4px;
}

.card-title {
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
  word-break: break-word;
  cursor: text;
}

.card-title-input {
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
  width: 100%;
  border: 1px solid var(--accent);
  border-radius: 4px;
  padding: 2px 4px;
  outline: none;
  font-family: inherit;
  box-sizing: border-box;
}

.card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
  color: var(--text-light);
}

.card-priority {
  padding: 1px 6px;
  border-radius: 3px;
  font-weight: 600;
  font-size: 10px;
  text-transform: uppercase;
}

.card-priority.high { background: #fde; color: var(--high); }
.card-priority.medium { background: #fff3e0; color: #e65100; }
.card-priority.low { background: #e8f5e9; color: #2e7d32; }

.card-assignee {
  display: flex;
  align-items: center;
  gap: 4px;
}

.card-meta {
  display: flex;
  gap: 6px;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

.badge {
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 3px;
  font-weight: 600;
}

.badge-estimate {
  background: #e3f2fd;
  color: #1565c0;
}

.badge-dep {
  background: #f3e5f5;
  color: #7b1fa2;
}

.card-deps {
  display: flex;
  gap: 3px;
  flex-wrap: wrap;
  margin-bottom: 4px;
  font-size: 9px;
  color: var(--text-light);
}

.card-deps span {
  background: #f3e5f5;
  color: #7b1fa2;
  padding: 0 4px;
  border-radius: 2px;
  font-weight: 500;
  max-width: 80px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.badge-sprint {
  background: #e0f2f1;
  color: #00695c;
}

.avatar {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: var(--accent);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 600;
}

/* Modal */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}

.modal-overlay.active { display: flex; }

.modal {
  background: #fff;
  border-radius: 10px;
  width: 440px;
  max-width: 95vw;
  max-height: 90vh;
  min-width: 320px;
  min-height: 300px;
  transition: width 0.2s ease;
  overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  position: relative;
}

.modal-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  width: 18px;
  height: 18px;
  cursor: nwse-resize;
  background: linear-gradient(135deg, transparent 50%, #ccc 50%, #ccc 60%, transparent 60%, transparent 70%, #ccc 70%, #ccc 80%, transparent 80%);
  border-radius: 0 0 10px 0;
  z-index: 10;
}

.modal-header {
  padding: 18px 20px;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header-fields {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.modal-key-editable, .modal-title-editable {
  cursor: text;
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid transparent;
  font-size: 16px;
  font-weight: 600;
}
.modal-key-editable:hover, .modal-title-editable:hover {
  border-color: #ccc;
  background: #f5f5f5;
}
.modal-key-editable {
  flex-shrink: 0;
  color: var(--accent);
}
.modal-title-editable {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.modal-key-input, .modal-title-input {
  font-size: 16px;
  font-weight: 600;
  font-family: inherit;
  border: 1px solid var(--accent);
  border-radius: 4px;
  padding: 2px 6px;
  outline: none;
}
.modal-key-input {
  width: 160px;
  flex-shrink: 0;
}
.modal-title-input {
  flex: 1;
  min-width: 0;
}

.modal-close {
  background: none;
  border: none;
  font-size: 22px;
  cursor: pointer;
  color: var(--text-light);
  line-height: 1;
}

.modal-body { padding: 20px; }

.form-group { margin-bottom: 14px; }

.form-group label {
  display: block;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-light);
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 8px 10px;
  border: 1px solid #ddd;
  border-radius: var(--radius);
  font-size: 14px;
  font-family: inherit;
  transition: border-color 0.15s;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--accent);
}

.form-group textarea { resize: vertical; min-height: 60px; }

#pinnedFieldsContainer .pinned-field-row {
  display: flex;
  align-items: flex-start;
  gap: 0;
  margin-bottom: 14px;
}

#pinnedFieldsContainer .pinned-field-row .form-group {
  flex: 1;
  margin-bottom: 0;
}

.pinned-drag-handle {
  width: 24px;
  min-height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: grab;
  opacity: 0;
  transition: opacity 0.15s;
  font-size: 18px;
  color: #333;
  user-select: none;
  flex-shrink: 0;
  margin-top: 18px;
  line-height: 1;
}

#pinnedFieldsContainer .pinned-field-row:hover .pinned-drag-handle {
  opacity: 0.5 !important;
}

.pinned-drag-handle:active,
.pinned-drag-handle.dragging {
  opacity: 1 !important;
  cursor: grabbing;
}

#pinnedFieldsContainer .pinned-field-row.drag-over-above {
  border-top: 2px solid var(--accent);
}

#pinnedFieldsContainer .pinned-field-row.drag-over-below {
  border-bottom: 2px solid var(--accent);
}

#pinnedFieldsContainer .pinned-field-row.pinned-dragging {
  opacity: 0.4;
}

.csv-fields-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 10px 0 6px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-light);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  user-select: none;
  border-top: 1px solid #eee;
  margin-top: 6px;
}

.csv-fields-toggle .arrow {
  transition: transform 0.15s;
  font-size: 10px;
}

.csv-fields-toggle .arrow.open {
  transform: rotate(90deg);
}

.csv-fields-extra {
  display: none;
}

.csv-fields-extra.open {
  display: block;
}

.csv-fields-filter {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid #ddd;
  border-radius: var(--radius);
  font-size: 13px;
  font-family: inherit;
  margin-bottom: 8px;
}

.csv-fields-filter:focus {
  outline: none;
  border-color: var(--accent);
}

#csvFieldsContainer {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 6px 10px;
}

#csvFieldsContainer .form-group {
  margin-bottom: 0;
}

#csvFieldsContainer .form-group label {
  font-size: 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  gap: 4px;
}

#csvFieldsContainer .form-group label input[type="checkbox"] {
  width: auto;
  margin: 0;
  flex-shrink: 0;
}

#csvFieldsContainer .form-group input,
#csvFieldsContainer .form-group textarea {
  padding: 4px 6px;
  font-size: 12px;
}

#csvFieldsContainer .form-group textarea {
  min-height: 32px;
}

/* Dependency dropdown widget */
.dep-widget {
  position: relative;
}
.dep-widget-row {
  display: flex;
  align-items: center;
  gap: 4px;
}
.dep-widget-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
  flex: 1;
  min-height: 28px;
  padding: 2px 4px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #fff;
  align-items: center;
  font-size: 12px;
}
.dep-tag {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  background: var(--accent);
  color: #fff;
  border-radius: 3px;
  padding: 1px 6px;
  font-size: 11px;
  white-space: nowrap;
}
.dep-tag-remove {
  cursor: pointer;
  font-size: 13px;
  line-height: 1;
  opacity: 0.8;
}
.dep-tag-remove:hover {
  opacity: 1;
}
.dep-dropdown-btn {
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 4px;
  width: 28px;
  height: 28px;
  cursor: pointer;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  opacity: 0.5;
}
.form-group:hover .dep-dropdown-btn,
.pinned-field-row:hover .dep-dropdown-btn {
  opacity: 1;
}
.dep-dropdown-btn:hover {
  background: var(--accent);
}
.dep-dropdown-list {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 200px;
  overflow-y: auto;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000;
  margin-top: 2px;
}
.dep-dropdown-list.open {
  display: block;
}
.dep-dropdown-item {
  padding: 6px 8px;
  cursor: pointer;
  font-size: 12px;
  border-bottom: 1px solid #f0f0f0;
}
.dep-dropdown-item:last-child {
  border-bottom: none;
}
.dep-dropdown-item:hover {
  background: #f0f5ff;
}
.dep-dropdown-item .dep-item-key {
  font-weight: 600;
  margin-right: 6px;
}

.modal-footer {
  padding: 14px 20px;
  border-top: 1px solid #eee;
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

/* Team capacity bar */
.team-capacity {
  display: none;
  padding: 10px 16px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  overflow-x: auto;
}

.team-capacity.active {
  display: flex;
  gap: 16px;
  align-items: stretch;
  flex-wrap: wrap;
}

.member-capacity {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--text);
  white-space: nowrap;
}

.member-capacity .avatar {
  width: 24px;
  height: 24px;
  font-size: 10px;
}

.member-capacity .member-name {
  font-weight: 600;
  min-width: 40px;
}

.member-capacity .capacity-bar {
  width: 80px;
  height: 6px;
  background: #e0e0e0;
  border-radius: 3px;
  overflow: hidden;
}

.member-capacity .capacity-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s;
}

.member-capacity .capacity-fill.under { background: var(--low); }
.member-capacity .capacity-fill.near { background: var(--medium); }
.member-capacity .capacity-fill.over { background: var(--high); }

.member-capacity .capacity-text {
  color: var(--text-light);
  font-size: 11px;
  min-width: 50px;
}

.member-capacity .capacity-avail {
  width: 36px;
  padding: 2px 4px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 11px;
  text-align: center;
  font-family: inherit;
  background: #fafafa;
}

.member-capacity .capacity-avail:focus {
  outline: none;
  border-color: var(--accent);
  background: #fff;
}

/* Dependency arrows overlay */
.dep-arrow-overlay {
  position: fixed;
  inset: 0;
  width: 15%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}

.dep-arrow-overlay g {
  opacity: 0;
  transition: opacity 0.15s;
}

.dep-arrow-overlay g.highlighted {
  opacity: 1;
}

.dep-arrow-overlay path {
  fill: none;
  stroke-width: 2.5;
  stroke-linecap: round;
}

.dep-arrow-overlay .in-from-below path { stroke: #43a047; }
.dep-arrow-overlay .in-from-below polygon { fill: #43a047; }
.dep-arrow-overlay .in-from-above path { stroke: #ef5350; }
.dep-arrow-overlay .in-from-above polygon { fill: #ef5350; }
.dep-arrow-overlay .out-up path { stroke: #0052cc; }
.dep-arrow-overlay .out-up polygon { fill: #0052cc; }
.dep-arrow-overlay .out-down path { stroke: #ef5350; }
.dep-arrow-overlay .out-down polygon { fill: #ef5350; }

/* Responsive */
@media (max-width: 768px) {
  .board {
    grid-template-columns: 1fr;
  }

  .header { gap: 12px; }
  .header-controls input[type="text"] { width: 120px; }
  .progress-bar { width: 100px; }
}
</style>
</head>
<body>

<header class="header">
  <h1>Sprint Board</h1>
  <div class="sprint-meta">
    <span id="sprintName">Sprint 1</span>
    <span id="sprintDates">Feb 15 – Feb 28, 2026</span>
  </div>
  <div class="progress-wrap">
    <div class="progress-bar"><div class="progress-bar-fill" id="progressFill"></div></div>
    <span class="progress-text" id="progressText">0%</span>
  </div>
  <div class="header-controls">
    <input type="text" id="searchInput" placeholder="Search issues...">
    <div class="view-toggle">
      <button id="viewBacklog">Backlog</button>
      <button id="viewBoard" class="active">Board</button>
    </div>
    <button class="btn btn-primary" id="createBtn">+ Create</button>
  </div>
</header>

<div class="team-capacity" id="teamCapacity"></div>

<div class="app-body">
  <main class="board" id="board">
    <div class="column" data-status="todo">
      <div class="column-header">To Do <span class="count" id="countTodo">0</span></div>
      <div class="column-body" data-status="todo"></div>
    </div>
    <div class="column" data-status="inprogress">
      <div class="column-header">In Progress <span class="count" id="countInprogress">0</span></div>
      <div class="column-body" data-status="inprogress"></div>
    </div>
    <div class="column" data-status="done">
      <div class="column-header">Done <span class="count" id="countDone">0</span></div>
      <div class="column-body" data-status="done"></div>
    </div>
  </main>

  <div class="backlog-view" id="backlogView"></div>
</div>

<!-- Create / Edit Modal -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal" id="modalDialog">
    <div class="modal-resize-handle" id="modalResizeHandle"></div>
    <div class="modal-header">
      <div class="modal-header-fields" id="modalHeaderFields"></div>
      <button class="modal-close" id="modalClose">&times;</button>
    </div>
    <div class="modal-body">
      <div id="pinnedFieldsContainer"></div>
      <div class="csv-fields-toggle" id="csvFieldsToggle">
        <span class="arrow" id="csvFieldsArrow">&#9654;</span>
        All CSV Fields
      </div>
      <div class="csv-fields-extra" id="csvFieldsExtra">
        <input type="text" class="csv-fields-filter" id="csvFieldsFilter" placeholder="Filter fields...">
        <div id="csvFieldsContainer"></div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-danger" id="deleteBtn" style="display:none;margin-right:auto;">Delete</button>
      <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
      <button class="btn btn-primary" id="saveBtn">Save</button>
    </div>
  </div>
</div>

<svg class="dep-arrow-overlay" id="depArrowOverlay" width="100%" height="100%"></svg>
<script src="/replan.js"></script>
<script>
(function() {
  // --- State ---
  let state = { nextId: 1, projectKey: 'SB', sprintStart: '2026-02-15', issues: [] };
  let fieldConfig = { visibleFields: [] }; // from server.conf
  let currentView = 'board'; // 'board' or 'backlog'

  async function loadConfig() {
    try {
      const res = await fetch('/api/config');
      fieldConfig = await res.json();
      if (!Array.isArray(fieldConfig.visibleFields)) fieldConfig.visibleFields = [];
    } catch(e) {
      fieldConfig = { visibleFields: [] };
    }
  }

  async function saveConfig() {
    try {
      await fetch('/api/config', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(fieldConfig)
      });
    } catch(e) {
      console.error('Failed to save config:', e);
    }
  }

  async function loadState() {
    try {
      const res = await fetch('/api/tasks');
      const data = await res.json();
      if (data && Array.isArray(data.issues)) {
        state = data;
        if (!state.sprintStart) state.sprintStart = '2026-02-15';
        if (!state.teamCapacity) state.teamCapacity = {};
        if (!state.csvHeaders) state.csvHeaders = [];
        // Migrate old flat teamCapacity { name: number } to per-sprint { name: { sprint: number } }
        Object.keys(state.teamCapacity).forEach(function(name) {
          if (typeof state.teamCapacity[name] === 'number') {
            state.teamCapacity[name] = { 1: state.teamCapacity[name] };
          }
        });
      }
    } catch(e) {
      console.error('Failed to load state:', e);
    }
  }

  async function saveState() {
    try {
      await fetch('/api/tasks', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(state)
      });
    } catch(e) {
      console.error('Failed to save state:', e);
    }
  }

  // --- Sprint date helpers ---
  function getSprintDateRange(sprintNum) {
    const start = new Date(state.sprintStart + 'T00:00:00');
    const sprintStart = new Date(start);
    sprintStart.setDate(sprintStart.getDate() + (sprintNum - 1) * 14);
    const sprintEnd = new Date(sprintStart);
    sprintEnd.setDate(sprintEnd.getDate() + 13);
    return { start: sprintStart, end: sprintEnd };
  }

  function formatDate(d) {
    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[d.getMonth()] + ' ' + d.getDate();
  }

  function formatDateRange(sprintNum) {
    const { start, end } = getSprintDateRange(sprintNum);
    const startYear = start.getFullYear();
    const endYear = end.getFullYear();
    if (startYear === endYear) {
      return formatDate(start) + ' \u2013 ' + formatDate(end) + ', ' + endYear;
    }
    return formatDate(start) + ', ' + startYear + ' \u2013 ' + formatDate(end) + ', ' + endYear;
  }

  // --- DOM refs ---
  const board = document.getElementById('board');
  const backlogView = document.getElementById('backlogView');
  const teamCapacityEl = document.getElementById('teamCapacity');
  const viewBoardBtn = document.getElementById('viewBoard');
  const viewBacklogBtn = document.getElementById('viewBacklog');
  const createBtn = document.getElementById('createBtn');
  const searchInput = document.getElementById('searchInput');
  const modalOverlay = document.getElementById('modalOverlay');
  const modalDialog = document.getElementById('modalDialog');
  const modalResizeHandle = document.getElementById('modalResizeHandle');
  const modalClose = document.getElementById('modalClose');

  // --- Custom modal resize (2x delta to compensate for centering) ---
  (function() {
    var resizing = false, startX, startY, startW, startH;
    modalResizeHandle.addEventListener('mousedown', function(e) {
      e.preventDefault();
      e.stopPropagation();
      resizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startW = modalDialog.offsetWidth;
      startH = modalDialog.offsetHeight;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    function onMouseMove(e) {
      if (!resizing) return;
      var dx = (e.clientX - startX) * 2;
      var dy = (e.clientY - startY) * 2;
      var newW = Math.max(320, Math.min(startW + dx, window.innerWidth * 0.95));
      var newH = Math.max(300, Math.min(startH + dy, window.innerHeight * 0.9));
      modalDialog.style.width = newW + 'px';
      modalDialog.style.height = newH + 'px';
    }
    function onMouseUp() {
      resizing = false;
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    }
  })();
  const saveBtn = document.getElementById('saveBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const modalHeaderFields = document.getElementById('modalHeaderFields');
  const pinnedFieldsContainer = document.getElementById('pinnedFieldsContainer');
  const csvFieldsToggle = document.getElementById('csvFieldsToggle');
  const csvFieldsArrow = document.getElementById('csvFieldsArrow');
  const csvFieldsExtra = document.getElementById('csvFieldsExtra');
  const csvFieldsFilter = document.getElementById('csvFieldsFilter');
  const csvFieldsContainer = document.getElementById('csvFieldsContainer');
  const progressFill = document.getElementById('progressFill');
  const progressText = document.getElementById('progressText');
  const sprintNameEl = document.getElementById('sprintName');
  const sprintDatesEl = document.getElementById('sprintDates');

  // CSV fields toggle
  csvFieldsToggle.addEventListener('click', function() {
    var isOpen = csvFieldsExtra.classList.toggle('open');
    csvFieldsArrow.classList.toggle('open', isOpen);
    // Widen modal to fit 4-column grid when open
    if (isOpen) {
      modalDialog.style.width = Math.min(1760, window.innerWidth * 0.95) + 'px';
    } else {
      modalDialog.style.width = '';
    }
  });

  csvFieldsFilter.addEventListener('input', function() {
    var q = csvFieldsFilter.value.toLowerCase();
    csvFieldsContainer.querySelectorAll('.form-group').forEach(function(fg) {
      var name = fg.dataset.colName || '';
      fg.style.display = name.toLowerCase().includes(q) ? '' : 'none';
    });
  });

  // Columns already handled by the main form fields
  var handledCsvCols = new Set([
    'Summary', 'Issue key', 'Issue id'
  ]);

  let editingId = null;

  // --- View toggle ---
  function setView(view) {
    currentView = view;
    if (view === 'board') {
      board.classList.remove('hidden');
      backlogView.classList.remove('active');
      teamCapacityEl.classList.add('active');
      viewBoardBtn.classList.add('active');
      viewBacklogBtn.classList.remove('active');
    } else {
      board.classList.add('hidden');
      backlogView.classList.add('active');
      teamCapacityEl.classList.remove('active');
      viewBoardBtn.classList.remove('active');
      viewBacklogBtn.classList.add('active');
    }
    render();
  }

  // --- Render ---
  function render() {
    if (currentView === 'board') {
      renderBoard();
    } else {
      renderBacklog();
    }
  }

  function renderBoard() {
    depArrowOverlay.innerHTML = '';
    const filter = searchInput.value.toLowerCase().trim();

    const columns = board.querySelectorAll('.column-body');
    columns.forEach(col => { col.innerHTML = ''; });

    const sprint1Issues = state.issues.filter(i => (i.sprint || 1) === 1);
    const counts = { todo: 0, inprogress: 0, done: 0 };

    sprint1Issues.forEach(issue => {
      counts[issue.status] = (counts[issue.status] || 0) + 1;

      if (filter) {
        const haystack = (issue.title + ' ' + issue.key + ' ' + (issue.assignee || '')).toLowerCase();
        if (!haystack.includes(filter)) return;
      }

      const card = createCard(issue);
      const col = board.querySelector('.column-body[data-status="' + issue.status + '"]');
      if (col) col.appendChild(card);
    });

    document.getElementById('countTodo').textContent = counts.todo;
    document.getElementById('countInprogress').textContent = counts.inprogress;
    document.getElementById('countDone').textContent = counts.done;

    // Progress for sprint 1
    const boardTotal = counts.todo + counts.inprogress + counts.done;
    const pct = boardTotal > 0 ? Math.round((counts.done / boardTotal) * 100) : 0;
    progressFill.style.width = pct + '%';
    progressText.textContent = pct + '%';

    // Header sprint info
    sprintNameEl.textContent = 'Sprint 1';
    sprintDatesEl.textContent = formatDateRange(1);

    renderTeamCapacity(sprint1Issues);
  }

  function getMemberCapacity(name, sprint) {
    if (!state.teamCapacity) state.teamCapacity = {};
    if (!state.teamCapacity[name]) state.teamCapacity[name] = {};
    return state.teamCapacity[name][sprint] != null ? state.teamCapacity[name][sprint] : 80;
  }

  function setMemberCapacity(name, sprint, value) {
    if (!state.teamCapacity) state.teamCapacity = {};
    if (!state.teamCapacity[name]) state.teamCapacity[name] = {};
    state.teamCapacity[name][sprint] = value;
  }

  function renderTeamCapacity(sprintIssues) {
    teamCapacityEl.innerHTML = '';

    // Collect unique assignees from all issues (not just this sprint)
    var members = new Set();
    state.issues.forEach(function(i) { if (i.assignee) members.add(i.assignee); });
    var sorted = Array.from(members).sort();

    // Sum assigned hours per member for this sprint
    var assigned = {};
    sprintIssues.forEach(function(i) {
      if (i.assignee && i.estimateHours) {
        assigned[i.assignee] = (assigned[i.assignee] || 0) + i.estimateHours;
      }
    });

    sorted.forEach(function(name) {
      var hrs = assigned[name] || 0;
      var avail = getMemberCapacity(name, 1);

      var pct = avail > 0 ? Math.min((hrs / avail) * 100, 100) : (hrs > 0 ? 100 : 0);
      var fillClass = pct <= 70 ? 'under' : pct <= 95 ? 'near' : 'over';

      var initials = name.split(' ').map(function(w) { return w[0]; }).join('').toUpperCase().slice(0, 2);

      var el = document.createElement('div');
      el.className = 'member-capacity';
      el.innerHTML =
        '<span class="avatar">' + initials + '</span>' +
        '<span class="member-name">' + escapeHtml(name) + '</span>' +
        '<div class="capacity-bar"><div class="capacity-fill ' + fillClass + '" style="width:' + pct + '%"></div></div>' +
        '<span class="capacity-text">' + hrs + 'h /</span>' +
        '<input type="number" class="capacity-avail" value="' + avail + '" min="0" step="1" title="Available hours for ' + escapeHtml(name) + '">' +
        '<span class="capacity-text">h</span>';

      var input = el.querySelector('.capacity-avail');
      input.addEventListener('change', function() {
        var val = parseInt(input.value, 10);
        if (isNaN(val) || val < 0) val = 0;
        input.value = val;
        setMemberCapacity(name, 1, val);
        saveState();
        renderBoard();
      });
      // Prevent card-like drag on the input
      input.addEventListener('click', function(e) { e.stopPropagation(); });

      teamCapacityEl.appendChild(el);
    });
  }

  function handleReplan() {
    state.issues = Replan.replan(state.issues, state.teamCapacity || {});
    saveState();
    renderBacklog();
  }

  function renderBacklog() {
    const filter = searchInput.value.toLowerCase().trim();
    backlogView.innerHTML = '';

    // Toolbar with Re-plan button
    var toolbar = document.createElement('div');
    toolbar.className = 'backlog-toolbar';
    var replanBtn = document.createElement('button');
    replanBtn.className = 'btn-replan';
    replanBtn.textContent = 'Re-plan';
    replanBtn.addEventListener('click', handleReplan);
    toolbar.appendChild(replanBtn);
    backlogView.appendChild(toolbar);

    // Collect all sprint numbers
    const sprintNums = new Set();
    state.issues.forEach(i => sprintNums.add(i.sprint || 1));
    const sorted = [...sprintNums].sort((a, b) => a - b);

    sorted.forEach(sprintNum => {
      const sprintIssues = state.issues.filter(i => (i.sprint || 1) === sprintNum);

      const section = document.createElement('div');
      section.className = 'sprint-section';

      const filteredIssues = filter
        ? sprintIssues.filter(i => {
            const haystack = (i.title + ' ' + i.key + ' ' + (i.assignee || '')).toLowerCase();
            return haystack.includes(filter);
          })
        : sprintIssues;

      const header = document.createElement('div');
      header.className = 'sprint-section-header';

      var headerLeft = document.createElement('div');
      headerLeft.innerHTML = '<h3 style="display:inline">Sprint ' + sprintNum + '</h3>' +
        '<span class="sprint-dates">' + formatDateRange(sprintNum) + '</span>';

      // Capacity inputs per member for this sprint
      var allMembers = new Set();
      state.issues.forEach(function(i) { if (i.assignee) allMembers.add(i.assignee); });
      var sortedMembers = Array.from(allMembers).sort();

      if (sortedMembers.length > 0) {
        var assignedHrs = {};
        sprintIssues.forEach(function(i) {
          if (i.assignee && i.estimateHours) {
            assignedHrs[i.assignee] = (assignedHrs[i.assignee] || 0) + i.estimateHours;
          }
        });

        var capContainer = document.createElement('span');
        capContainer.className = 'sprint-capacity';

        sortedMembers.forEach(function(name) {
          var hrs = assignedHrs[name] || 0;
          var avail = getMemberCapacity(name, sprintNum);

          var memberCap = document.createElement('span');
          memberCap.className = 'sprint-member-cap';

          var label = document.createElement('span');
          label.className = 'member-label';
          label.textContent = name + ':';

          var capInput = document.createElement('input');
          capInput.type = 'number';
          capInput.value = avail;
          capInput.min = '0';
          capInput.step = '1';
          capInput.title = 'Available hours for ' + name + ' in Sprint ' + sprintNum;
          capInput.addEventListener('click', function(e) { e.stopPropagation(); });
          capInput.addEventListener('change', function() {
            var val = parseInt(capInput.value, 10);
            if (isNaN(val) || val < 0) val = 0;
            capInput.value = val;
            setMemberCapacity(name, sprintNum, val);
            saveState();
            renderBacklog();
          });

          memberCap.appendChild(label);
          memberCap.appendChild(document.createTextNode(' ' + hrs + '/'));
          memberCap.appendChild(capInput);
          memberCap.appendChild(document.createTextNode('h'));

          capContainer.appendChild(memberCap);
        });

        headerLeft.appendChild(capContainer);
      }

      var headerRight = document.createElement('span');
      headerRight.className = 'sprint-count';
      headerRight.textContent = sprintIssues.length + ' task' + (sprintIssues.length !== 1 ? 's' : '');

      header.appendChild(headerLeft);
      header.appendChild(headerRight);

      const body = document.createElement('div');
      body.className = 'sprint-section-body';
      body.dataset.sprint = sprintNum;

      filteredIssues.forEach(issue => {
        const card = createCard(issue, true);
        body.appendChild(card);
      });

      section.appendChild(header);
      section.appendChild(body);
      backlogView.appendChild(section);
    });

    setupBacklogDropZones();
    renderAllDepArrows();
  }

  function createCard(issue, showStatus) {
    const card = document.createElement('div');
    card.className = 'card priority-' + issue.priority + (issue.status === 'done' ? ' status-done' : '');
    card.draggable = true;
    card.dataset.id = issue.id;

    const initials = issue.assignee
      ? issue.assignee.split(' ').map(function(w) { return w[0]; }).join('').toUpperCase().slice(0, 2)
      : '';

    var deps = issue.dependsOn || [];
    if (!Array.isArray(deps)) deps = deps ? [deps] : [];
    var depIssues = deps.map(function(depId) {
      return state.issues.find(function(i) { return i.id === depId; });
    }).filter(Boolean);

    var metaHtml = '';
    var hasMeta = (issue.estimateHours && issue.estimateHours > 0) || depIssues.length > 0 || showStatus;
    if (hasMeta) {
      metaHtml = '<div class="card-meta">';
      if (issue.estimateHours && issue.estimateHours > 0) {
        metaHtml += '<span class="badge badge-estimate">' + issue.estimateHours + 'h</span>';
      }
      if (depIssues.length > 0) {
        metaHtml += '<span class="badge badge-dep">blocked by ' + depIssues.map(function(d) { return d.key; }).join(', ') + '</span>';
      }
      if (showStatus) {
        var statusLabel = issue.status === 'inprogress' ? 'In Progress' : issue.status === 'todo' ? 'To Do' : 'Done';
        metaHtml += '<span class="badge badge-sprint">' + statusLabel + '</span>';
      }
      metaHtml += '</div>';
    }

    // Dependency name hints for backlog view
    var depsHintHtml = '';
    if (showStatus && depIssues.length > 0) {
      depsHintHtml = '<div class="card-deps">';
      depIssues.forEach(function(d) {
        var name = d.title.length > 10 ? d.title.substring(0, 10) + '\u2026' : d.title;
        depsHintHtml += '<span title="' + escapeHtml(d.key + ' \u2013 ' + d.title) + '">' + escapeHtml(name) + '</span>';
      });
      depsHintHtml += '</div>';
    }

    card.innerHTML =
      '<div class="card-key">' + issue.key + '</div>' +
      '<div class="card-title">' + escapeHtml(issue.title) + '</div>' +
      depsHintHtml +
      metaHtml +
      '<div class="card-footer">' +
        '<span class="card-priority ' + issue.priority + '">' + issue.priority + '</span>' +
        (issue.assignee
          ? '<span class="card-assignee"><span class="avatar">' + initials + '</span>' + escapeHtml(issue.assignee) + '</span>'
          : '') +
      '</div>';

    // Drag events
    card.addEventListener('dragstart', function(e) {
      card.classList.add('dragging');
      e.dataTransfer.setData('text/plain', issue.id);
      e.dataTransfer.effectAllowed = 'move';
      if (currentView === 'backlog') {
        dragCardHeight = card.getBoundingClientRect().height;
        setTimeout(function() {
          var oldPos = snapshotCardPositions();
          card.classList.add('drag-collapse');
          animateFlip(oldPos);
        }, 0);
      }
    });

    card.addEventListener('dragend', function() {
      card.classList.remove('dragging');
      card.classList.remove('drag-collapse');
      cleanupPlaceholder();
      if (currentView === 'backlog') {
        renderBacklog();
      }
    });

    // Highlight dependency arrows on hover (backlog view)
    if (showStatus) {
      card.addEventListener('mouseenter', function() { highlightDepArrows(issue.id); });
      card.addEventListener('mouseleave', function() { unhighlightDepArrows(); });
    }

    // Click on title to inline-edit
    var titleEl = card.querySelector('.card-title');
    titleEl.addEventListener('click', function(e) {
      e.stopPropagation();
      var input = document.createElement('input');
      input.type = 'text';
      input.className = 'card-title-input';
      input.value = issue.title;
      titleEl.replaceWith(input);
      input.focus();
      input.select();

      function commitEdit() {
        var newTitle = input.value.trim();
        if (newTitle && newTitle !== issue.title) {
          issue.title = newTitle;
          var summaryIdx = (state.csvHeaders || []).indexOf('Summary');
          if (issue.rawRow && summaryIdx >= 0) {
            while (issue.rawRow.length <= summaryIdx) issue.rawRow.push('');
            issue.rawRow[summaryIdx] = newTitle;
          }
          saveState();
        }
        render();
      }

      input.addEventListener('blur', commitEdit);
      input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') { input.blur(); }
        if (e.key === 'Escape') { input.removeEventListener('blur', commitEdit); render(); }
      });
      // Prevent drag while editing
      input.addEventListener('mousedown', function(e) { e.stopPropagation(); });
      input.addEventListener('dragstart', function(e) { e.preventDefault(); });
    });

    // Click on rest of card to open modal
    card.addEventListener('click', function() { openEditModal(issue.id); });

    return card;
  }

  // --- Drag & Drop on board columns ---
  function setupDropZones() {
    var zones = board.querySelectorAll('.column-body');

    zones.forEach(function(zone) {
      zone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        zone.classList.add('drag-over');
      });

      zone.addEventListener('dragleave', function(e) {
        if (!zone.contains(e.relatedTarget)) {
          zone.classList.remove('drag-over');
        }
      });

      zone.addEventListener('drop', function(e) {
        e.preventDefault();
        zone.classList.remove('drag-over');
        var id = parseInt(e.dataTransfer.getData('text/plain'), 10);
        var newStatus = zone.dataset.status;
        var issue = state.issues.find(function(i) { return i.id === id; });
        if (issue && newStatus) {
          issue.status = newStatus;
          saveState();
          render();
        }
      });
    });
  }

  // --- FLIP animation for backlog reorder ---
  var placeholder = null;
  var currentPreviewZone = null;
  var currentPreviewIndex = -1;
  var dragCardHeight = 60;
  var placeholderCleanupTimer = null;

  function snapshotCardPositions() {
    var positions = {};
    backlogView.querySelectorAll('.card:not(.drag-collapse)').forEach(function(card) {
      var id = card.dataset.id;
      var rect = card.getBoundingClientRect();
      positions[id] = { top: rect.top, left: rect.left };
    });
    return positions;
  }

  function cancelOngoingFlips() {
    backlogView.querySelectorAll('.card.flip-animate').forEach(function(card) {
      card.classList.remove('flip-animate');
      card.style.transform = '';
      card.style.transition = '';
    });
  }

  function animateFlip(oldPositions) {
    var cards = backlogView.querySelectorAll('.card:not(.drag-collapse)');
    cards.forEach(function(card) {
      var id = card.dataset.id;
      var oldPos = oldPositions[id];
      if (!oldPos) return;
      var newRect = card.getBoundingClientRect();
      var dx = oldPos.left - newRect.left;
      var dy = oldPos.top - newRect.top;
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
      card.style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
      card.style.transition = 'none';
      requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          card.classList.add('flip-animate');
          card.style.transform = '';
          card.style.transition = '';
          function onEnd() {
            card.classList.remove('flip-animate');
            card.removeEventListener('transitionend', onEnd);
          }
          card.addEventListener('transitionend', onEnd);
        });
      });
    });
  }

  function cleanupPlaceholder() {
    if (placeholderCleanupTimer) {
      clearTimeout(placeholderCleanupTimer);
      placeholderCleanupTimer = null;
    }
    if (placeholder && placeholder.parentNode) {
      placeholder.parentNode.removeChild(placeholder);
    }
    placeholder = null;
    currentPreviewZone = null;
    currentPreviewIndex = -1;
  }

  // --- Drag & Drop on backlog sprint sections (with reorder) ---
  function getDropTarget(zone, y) {
    var cards = Array.from(zone.querySelectorAll('.card:not(.dragging):not(.drag-collapse)'));
    for (var i = 0; i < cards.length; i++) {
      var rect = cards[i].getBoundingClientRect();
      var mid = rect.top + rect.height / 2;
      if (y < mid) {
        return { index: i };
      }
    }
    return { index: cards.length };
  }

  function setupBacklogDropZones() {
    var zones = backlogView.querySelectorAll('.sprint-section-body');

    zones.forEach(function(zone) {
      zone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        if (placeholderCleanupTimer) {
          clearTimeout(placeholderCleanupTimer);
          placeholderCleanupTimer = null;
        }

        var target = getDropTarget(zone, e.clientY);

        // Skip if position hasn't changed
        if (zone === currentPreviewZone && target.index === currentPreviewIndex) return;

        cancelOngoingFlips();
        var oldPos = snapshotCardPositions();

        // Remove placeholder from old location
        if (placeholder && placeholder.parentNode) {
          placeholder.parentNode.removeChild(placeholder);
        }

        // Create placeholder if needed
        if (!placeholder) {
          placeholder = document.createElement('div');
          placeholder.className = 'card-placeholder';
        }
        placeholder.style.height = dragCardHeight + 'px';

        // Insert at target position
        var cards = Array.from(zone.querySelectorAll('.card:not(.dragging):not(.drag-collapse)'));
        if (target.index < cards.length) {
          zone.insertBefore(placeholder, cards[target.index]);
        } else {
          zone.appendChild(placeholder);
        }

        currentPreviewZone = zone;
        currentPreviewIndex = target.index;

        animateFlip(oldPos);
      });

      zone.addEventListener('dragleave', function(e) {
        if (!zone.contains(e.relatedTarget)) {
          // Delay cleanup so moving between zones doesn't flash
          placeholderCleanupTimer = setTimeout(function() {
            cancelOngoingFlips();
            var oldPos = snapshotCardPositions();
            cleanupPlaceholder();
            animateFlip(oldPos);
          }, 50);
        }
      });

      zone.addEventListener('drop', function(e) {
        e.preventDefault();

        var draggedId = parseInt(e.dataTransfer.getData('text/plain'), 10);
        var newSprint = parseInt(zone.dataset.sprint, 10);
        var issue = state.issues.find(function(i) { return i.id === draggedId; });
        if (!issue || !newSprint) return;

        // Snapshot with placeholder in place — use placeholder rect for the dropped card
        var oldPositions = snapshotCardPositions();
        if (placeholder) {
          var phRect = placeholder.getBoundingClientRect();
          oldPositions[String(draggedId)] = { top: phRect.top, left: phRect.left };
        }

        // Remove from current position
        var oldIndex = state.issues.indexOf(issue);
        state.issues.splice(oldIndex, 1);

        // Update sprint
        issue.sprint = newSprint;

        // Determine the reference card at drop index among visible cards in this sprint
        var visibleInSprint = state.issues.filter(function(i) { return i.sprint === newSprint; });
        var dropIndex = currentPreviewIndex;

        if (visibleInSprint.length === 0) {
          // Empty sprint — find insertion point after previous sprint's issues
          var insertAt = 0;
          for (var s = newSprint - 1; s >= 1; s--) {
            for (var j = state.issues.length - 1; j >= 0; j--) {
              if (state.issues[j].sprint === s) {
                insertAt = j + 1;
                s = 0;
                break;
              }
            }
          }
          state.issues.splice(insertAt, 0, issue);
        } else if (dropIndex >= visibleInSprint.length) {
          var lastInSprint = visibleInSprint[visibleInSprint.length - 1];
          var globalIdx = state.issues.indexOf(lastInSprint);
          state.issues.splice(globalIdx + 1, 0, issue);
        } else {
          var refIssue = visibleInSprint[dropIndex];
          var globalIdx = state.issues.indexOf(refIssue);
          state.issues.splice(globalIdx, 0, issue);
        }

        cleanupPlaceholder();
        saveState();
        renderBacklog();
        animateFlip(oldPositions);
      });
    });
  }

  // --- Modal ---
  var modalValues = { key: '', title: '' };

  function setupHeaderFields(issue) {
    var keyVal = issue ? issue.key : state.projectKey + '-' + state.nextId;
    var titleVal = issue ? issue.title : '';
    modalValues.key = keyVal;
    modalValues.title = titleVal;
    modalHeaderFields.innerHTML =
      '<span class="modal-key-editable" id="modalKeyEditable">' + escapeHtml(keyVal) + '</span>' +
      '<span class="modal-title-editable" id="modalTitleEditable">' + (titleVal ? escapeHtml(titleVal) : '<span style="color:#999">Issue summary</span>') + '</span>';

    function makeEditable(el, inputClass, currentVal, onCommit) {
      el.addEventListener('click', function handler() {
        var input = document.createElement('input');
        input.type = 'text';
        input.className = inputClass;
        input.value = currentVal();
        el.replaceWith(input);
        input.focus();
        input.select();

        function commit() {
          var v = input.value.trim();
          onCommit(v);
          // Rebuild header fields to reflect changes
          setupHeaderFields(issue);
        }
        input.addEventListener('blur', commit);
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') input.blur();
          if (e.key === 'Escape') { input.removeEventListener('blur', commit); setupHeaderFields(issue); }
        });
      });
    }

    var keyEl = document.getElementById('modalKeyEditable');
    var titleEl = document.getElementById('modalTitleEditable');

    makeEditable(keyEl, 'modal-key-input', function() { return keyVal; }, function(v) {
      if (v && issue) {
        issue.key = v;
        var keyIdx = (state.csvHeaders || []).indexOf('Issue key');
        if (issue.rawRow && keyIdx >= 0) {
          while (issue.rawRow.length <= keyIdx) issue.rawRow.push('');
          issue.rawRow[keyIdx] = v;
        }
      }
      keyVal = v || keyVal;
      modalValues.key = keyVal;
    });

    makeEditable(titleEl, 'modal-title-input', function() { return titleVal; }, function(v) {
      if (issue) {
        issue.title = v || issue.title;
        var summaryIdx = (state.csvHeaders || []).indexOf('Summary');
        if (issue.rawRow && summaryIdx >= 0) {
          while (issue.rawRow.length <= summaryIdx) issue.rawRow.push('');
          issue.rawRow[summaryIdx] = issue.title;
        }
      }
      titleVal = v || titleVal;
      modalValues.title = titleVal;
    });
  }

  function getModalTitle() {
    // Check if an input is active (user is typing)
    var input = modalHeaderFields.querySelector('.modal-title-input');
    if (input) return input.value.trim();
    return modalValues.title;
  }

  function getModalKey() {
    var input = modalHeaderFields.querySelector('.modal-key-input');
    if (input) return input.value.trim();
    return modalValues.key;
  }

  function openCreateModal() {
    editingId = null;
    setupHeaderFields(null);
    populatePinnedFields(null);
    populateCsvFields(null);
    deleteBtn.style.display = 'none';
    saveBtn.textContent = 'Create';
    modalOverlay.classList.add('active');
    document.getElementById('modalTitleEditable').click();
  }

  function isFieldVisible(header) {
    return fieldConfig.visibleFields.indexOf(header) !== -1;
  }

  function toggleFieldVisibility(header) {
    var idx = fieldConfig.visibleFields.indexOf(header);
    if (idx !== -1) {
      fieldConfig.visibleFields.splice(idx, 1);
    } else {
      fieldConfig.visibleFields.push(header);
    }
    saveConfig();
    // Re-render pinned fields with current issue data
    var issue = editingId !== null ? state.issues.find(function(i) { return i.id === editingId; }) : null;
    populatePinnedFields(issue);
  }

  var DEP_COLUMNS = ['Inward issue link (Depends)', 'Inward issue link (Finish to Start)'];

  function isDependencyColumn(idx) {
    var headers = state.csvHeaders || [];
    return idx >= 0 && idx < headers.length && DEP_COLUMNS.indexOf(headers[idx]) !== -1;
  }

  function createDepWidget(val, idx) {
    var widget = document.createElement('div');
    widget.className = 'dep-widget';

    // Hidden input to hold the actual value for save
    var hidden = document.createElement('input');
    hidden.type = 'hidden';
    hidden.value = val;
    hidden.dataset.csvIdx = idx;
    hidden.className = 'csv-field-input';
    widget.appendChild(hidden);

    var row = document.createElement('div');
    row.className = 'dep-widget-row';

    var tagsContainer = document.createElement('div');
    tagsContainer.className = 'dep-widget-tags';

    var btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'dep-dropdown-btn';
    btn.innerHTML = '&#9660;'; // ▼

    var dropdown = document.createElement('div');
    dropdown.className = 'dep-dropdown-list';

    row.appendChild(tagsContainer);
    row.appendChild(btn);
    widget.appendChild(row);
    widget.appendChild(dropdown);

    // Current issue being edited
    var currentIssueId = editingId;

    function getDepIds() {
      return hidden.value.trim() ? hidden.value.split(/\s*;\s*/).map(function(s) { return s.trim(); }).filter(Boolean) : [];
    }

    function setDepIds(ids) {
      hidden.value = ids.join('; ');
    }

    function renderTags() {
      tagsContainer.innerHTML = '';
      var ids = getDepIds();
      if (ids.length === 0) {
        var placeholder = document.createElement('span');
        placeholder.style.color = '#999';
        placeholder.style.fontSize = '11px';
        placeholder.textContent = 'No dependencies';
        tagsContainer.appendChild(placeholder);
        return;
      }
      ids.forEach(function(depId) {
        var tag = document.createElement('span');
        tag.className = 'dep-tag';
        // Find issue key for display
        var depIssue = state.issues.find(function(i) { return String(i.id) === depId || i.key === depId; });
        tag.textContent = depIssue ? depIssue.key : depId;
        var removeBtn = document.createElement('span');
        removeBtn.className = 'dep-tag-remove';
        removeBtn.textContent = '\u00d7';
        removeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          var currentIds = getDepIds().filter(function(d) { return d !== depId; });
          setDepIds(currentIds);
          renderTags();
        });
        tag.appendChild(removeBtn);
        tagsContainer.appendChild(tag);
      });
    }

    function renderDropdown() {
      dropdown.innerHTML = '';
      var currentDeps = getDepIds();
      var issues = state.issues || [];
      issues.forEach(function(issue) {
        // Don't show current issue or already-added deps
        if (issue.id === currentIssueId) return;
        if (currentDeps.indexOf(String(issue.id)) !== -1) return;

        var item = document.createElement('div');
        item.className = 'dep-dropdown-item';
        var keySpan = document.createElement('span');
        keySpan.className = 'dep-item-key';
        keySpan.textContent = issue.key;
        item.appendChild(keySpan);
        item.appendChild(document.createTextNode(issue.title));
        item.addEventListener('click', function() {
          var ids = getDepIds();
          ids.push(String(issue.id));
          setDepIds(ids);
          renderTags();
          dropdown.classList.remove('open');
          renderDropdown(); // refresh to remove added item
        });
        dropdown.appendChild(item);
      });
      if (dropdown.children.length === 0) {
        var empty = document.createElement('div');
        empty.className = 'dep-dropdown-item';
        empty.style.color = '#999';
        empty.textContent = 'No tasks available';
        dropdown.appendChild(empty);
      }
    }

    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      var isOpen = dropdown.classList.contains('open');
      // Close all other dropdowns first
      document.querySelectorAll('.dep-dropdown-list.open').forEach(function(d) { d.classList.remove('open'); });
      if (!isOpen) {
        renderDropdown();
        dropdown.classList.add('open');
      }
    });

    // Close dropdown on outside click
    document.addEventListener('click', function(e) {
      if (!widget.contains(e.target)) {
        dropdown.classList.remove('open');
      }
    });

    renderTags();
    return widget;
  }

  function createFieldInput(val, idx) {
    if (isDependencyColumn(idx)) {
      return createDepWidget(val, idx);
    }
    var input;
    if (val.length > 80 || val.includes('\n')) {
      input = document.createElement('textarea');
      input.rows = 3;
    } else {
      input = document.createElement('input');
      input.type = 'text';
    }
    input.value = val;
    input.dataset.csvIdx = idx;
    input.className = 'csv-field-input';
    return input;
  }

  var pinnedDragState = { dragging: null };

  function pinnedDragReorder(fromHeader, toHeader, insertBefore) {
    var fromIdx = fieldConfig.visibleFields.indexOf(fromHeader);
    if (fromIdx === -1) return;
    // Remove from old position
    fieldConfig.visibleFields.splice(fromIdx, 1);
    // Find new position
    var toIdx = fieldConfig.visibleFields.indexOf(toHeader);
    if (toIdx === -1) {
      fieldConfig.visibleFields.push(fromHeader);
    } else {
      if (insertBefore) {
        fieldConfig.visibleFields.splice(toIdx, 0, fromHeader);
      } else {
        fieldConfig.visibleFields.splice(toIdx + 1, 0, fromHeader);
      }
    }
    saveConfig();
    // Re-render preserving current input values
    var issue = editingId !== null ? state.issues.find(function(i) { return i.id === editingId; }) : null;
    // Snapshot current input values before re-render
    var inputValues = {};
    pinnedFieldsContainer.querySelectorAll('.csv-field-input').forEach(function(input) {
      inputValues[input.dataset.csvIdx] = input.value;
    });
    populatePinnedFields(issue);
    // Restore edited values
    pinnedFieldsContainer.querySelectorAll('.csv-field-input').forEach(function(input) {
      if (inputValues[input.dataset.csvIdx] !== undefined) {
        input.value = inputValues[input.dataset.csvIdx];
      }
    });
  }

  function populatePinnedFields(issue) {
    pinnedFieldsContainer.innerHTML = '';
    var headers = state.csvHeaders || [];
    var rawRow = issue ? (issue.rawRow || []) : [];
    if (headers.length === 0 || fieldConfig.visibleFields.length === 0) return;

    // Render in the order defined by visibleFields
    fieldConfig.visibleFields.forEach(function(header) {
      var idx = headers.indexOf(header);
      if (idx === -1) return;
      if (handledCsvCols.has(header)) return;

      var row = document.createElement('div');
      row.className = 'pinned-field-row';
      row.dataset.pinnedHeader = header;

      // Drag handle
      var handle = document.createElement('span');
      handle.className = 'pinned-drag-handle';
      handle.innerHTML = '&#9776;'; // hamburger icon ☰
      handle.draggable = true;
      handle.addEventListener('dragstart', function(e) {
        pinnedDragState.dragging = header;
        handle.classList.add('dragging');
        row.classList.add('pinned-dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', header);
      });
      handle.addEventListener('dragend', function() {
        handle.classList.remove('dragging');
        row.classList.remove('pinned-dragging');
        pinnedDragState.dragging = null;
        pinnedFieldsContainer.querySelectorAll('.drag-over-above, .drag-over-below').forEach(function(el) {
          el.classList.remove('drag-over-above', 'drag-over-below');
        });
      });

      row.addEventListener('dragover', function(e) {
        if (!pinnedDragState.dragging) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        var rect = row.getBoundingClientRect();
        var mid = rect.top + rect.height / 2;
        row.classList.toggle('drag-over-above', e.clientY < mid);
        row.classList.toggle('drag-over-below', e.clientY >= mid);
      });
      row.addEventListener('dragleave', function() {
        row.classList.remove('drag-over-above', 'drag-over-below');
      });
      row.addEventListener('drop', function(e) {
        e.preventDefault();
        row.classList.remove('drag-over-above', 'drag-over-below');
        var fromHeader = pinnedDragState.dragging;
        if (!fromHeader || fromHeader === header) return;
        var rect = row.getBoundingClientRect();
        var insertBefore = e.clientY < rect.top + rect.height / 2;
        pinnedDragReorder(fromHeader, header, insertBefore);
      });

      var fg = document.createElement('div');
      fg.className = 'form-group';
      fg.dataset.colName = header;
      var lbl = document.createElement('label');
      lbl.textContent = header;
      var val = idx < rawRow.length ? rawRow[idx] : '';
      var input = createFieldInput(val, idx);
      fg.appendChild(lbl);
      fg.appendChild(input);

      row.appendChild(handle);
      row.appendChild(fg);
      pinnedFieldsContainer.appendChild(row);
    });
  }

  function populateCsvFields(issue) {
    csvFieldsContainer.innerHTML = '';
    csvFieldsFilter.value = '';
    var headers = state.csvHeaders || [];
    var rawRow = issue ? (issue.rawRow || []) : [];
    if (headers.length === 0) {
      csvFieldsContainer.innerHTML = '<p style="font-size:12px;color:var(--text-light)">No CSV columns available.</p>';
      return;
    }
    headers.forEach(function(header, idx) {
      if (handledCsvCols.has(header)) return;
      var fg = document.createElement('div');
      fg.className = 'form-group';
      fg.dataset.colName = header;

      var lbl = document.createElement('label');
      var cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = isFieldVisible(header);
      cb.addEventListener('change', function(e) {
        e.stopPropagation();
        toggleFieldVisibility(header);
      });
      lbl.appendChild(cb);
      lbl.appendChild(document.createTextNode(' ' + header));

      var val = idx < rawRow.length ? rawRow[idx] : '';
      var input = createFieldInput(val, idx);
      fg.appendChild(lbl);
      fg.appendChild(input);
      csvFieldsContainer.appendChild(fg);
    });
  }

  function openEditModal(id) {
    var issue = state.issues.find(function(i) { return i.id === id; });
    if (!issue) return;
    editingId = id;
    setupHeaderFields(issue);
    populatePinnedFields(issue);
    populateCsvFields(issue);
    deleteBtn.style.display = 'inline-block';
    saveBtn.textContent = 'Update';
    modalOverlay.classList.add('active');
  }

  function closeModal() {
    modalOverlay.classList.remove('active');
    modalDialog.style.width = '';
    modalDialog.style.height = '';
    csvFieldsExtra.classList.remove('open');
    csvFieldsArrow.classList.remove('open');
    editingId = null;
  }

  function handleSave() {
    var title = getModalTitle();
    var key = getModalKey();
    if (!title) {
      var titleEl = document.getElementById('modalTitleEditable');
      if (titleEl) { titleEl.style.borderColor = 'var(--high)'; titleEl.click(); }
      return;
    }

    // Collect edited CSV field values into rawRow
    function collectRawRow(existingRaw) {
      var raw = existingRaw ? [...existingRaw] : [];
      // Collect from both pinned fields and all-CSV-fields
      // Pinned fields last so they take priority over CSV fields panel
      var containers = [csvFieldsContainer, pinnedFieldsContainer];
      containers.forEach(function(container) {
        container.querySelectorAll('.csv-field-input').forEach(function(input) {
          var idx = parseInt(input.dataset.csvIdx, 10);
          if (!isNaN(idx)) {
            while (raw.length <= idx) raw.push('');
            raw[idx] = input.value;
          }
        });
      });
      return raw;
    }

    // Sync dependsOn from rawRow dependency columns
    function syncDependsOn(raw) {
      var headers = state.csvHeaders || [];
      var depCols = ['Inward issue link (Depends)', 'Inward issue link (Finish to Start)'];
      var allDeps = [];
      depCols.forEach(function(col) {
        var idx = headers.indexOf(col);
        if (idx >= 0 && idx < raw.length && raw[idx]) {
          raw[idx].split(/\s*;\s*/).forEach(function(s) {
            var v = s.trim();
            if (v) {
              var n = parseInt(v, 10);
              if (!isNaN(n) && allDeps.indexOf(n) === -1) allDeps.push(n);
            }
          });
        }
      });
      return allDeps;
    }

    if (editingId !== null) {
      var issue = state.issues.find(function(i) { return i.id === editingId; });
      if (issue) {
        issue.title = title;
        if (key) issue.key = key;
        issue.rawRow = collectRawRow(issue.rawRow);
        issue.dependsOn = syncDependsOn(issue.rawRow);
      }
    } else {
      var newRaw = collectRawRow([]);
      state.issues.push({
        id: state.nextId,
        key: key || state.projectKey + '-' + state.nextId,
        title: title,
        description: '',
        estimateHours: 0,
        dependsOn: syncDependsOn(newRaw),
        priority: 'medium',
        assignee: '',
        status: 'todo',
        sprint: 1,
        rawRow: newRaw
      });
      state.nextId++;
    }

    saveState();
    closeModal();
    render();
  }

  function handleDelete() {
    if (editingId === null) return;
    state.issues.forEach(function(i) {
      if (Array.isArray(i.dependsOn)) {
        i.dependsOn = i.dependsOn.filter(function(d) { return d !== editingId; });
      }
    });
    state.issues = state.issues.filter(function(i) { return i.id !== editingId; });
    saveState();
    closeModal();
    render();
  }

  // --- Helpers ---
  function escapeHtml(str) {
    var div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // --- Dependency arrow drawing ---
  var depArrowOverlay = document.getElementById('depArrowOverlay');

  function drawArrowForIssue(issue) {
    var deps = issue.dependsOn || [];
    if (!Array.isArray(deps)) deps = deps ? [deps] : [];
    if (deps.length === 0) return;

    var sourceCard = backlogView.querySelector('.card[data-id="' + issue.id + '"]');
    if (!sourceCard) return;

    deps.forEach(function(depId) {
      var targetCard = backlogView.querySelector('.card[data-id="' + depId + '"]');
      if (!targetCard) return;

      var srcRect = sourceCard.getBoundingClientRect();
      var tgtRect = targetCard.getBoundingClientRect();

      var sx = srcRect.left;
      var tx = tgtRect.left;

      // Determine direction from card centers
      var srcMidY = srcRect.top + srcRect.height / 2;
      var tgtMidY = tgtRect.top + tgtRect.height / 2;
      var goesUp = tgtMidY < srcMidY;

      // Upward: start at 33% from top, end at 33% from bottom (67% from top)
      // Downward: start at 33% from bottom (67% from top), end at 33% from top
      var sy, ty;
      if (goesUp) {
        sy = srcRect.top + srcRect.height * 0.33;
        ty = tgtRect.top + tgtRect.height * 0.67;
      } else {
        sy = srcRect.top + srcRect.height * 0.67;
        ty = tgtRect.top + tgtRect.height * 0.33;
      }

      var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.dataset.issueId = issue.id;
      g.dataset.targetId = depId;
      // source below target: incoming from below (green), outgoing goes up (blue)
      // source above target: incoming from above (yellow), outgoing goes down (red)
      g.dataset.inClass = sy > ty ? 'in-from-below' : 'in-from-above';
      g.dataset.outClass = sy > ty ? 'out-up' : 'out-down';

      // Blocky right-angle path with tight rounded corners
      // Downward arrows extend 5vw further left for visual distinction
      var offset = ty > sy ? 25 + window.innerWidth * 0.005 : 25;
      var r = 6;
      var mx = Math.min(sx, tx) - offset;
      var dy = Math.abs(ty - sy);
      var cr = Math.min(r, dy / 2, offset);

      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      if (ty < sy) {
        path.setAttribute('d',
          'M ' + sx + ' ' + sy +
          ' L ' + (mx + cr) + ' ' + sy +
          ' Q ' + mx + ' ' + sy + ' ' + mx + ' ' + (sy - cr) +
          ' L ' + mx + ' ' + (ty + cr) +
          ' Q ' + mx + ' ' + ty + ' ' + (mx + cr) + ' ' + ty +
          ' L ' + tx + ' ' + ty
        );
      } else {
        path.setAttribute('d',
          'M ' + sx + ' ' + sy +
          ' L ' + (mx + cr) + ' ' + sy +
          ' Q ' + mx + ' ' + sy + ' ' + mx + ' ' + (sy + cr) +
          ' L ' + mx + ' ' + (ty - cr) +
          ' Q ' + mx + ' ' + ty + ' ' + (mx + cr) + ' ' + ty +
          ' L ' + tx + ' ' + ty
        );
      }
      g.appendChild(path);

      var arrowSize = 7;
      var angle = 0;
      var p1x = tx - arrowSize * Math.cos(angle - 0.4);
      var p1y = ty - arrowSize * Math.sin(angle - 0.4);
      var p2x = tx - arrowSize * Math.cos(angle + 0.4);
      var p2y = ty - arrowSize * Math.sin(angle + 0.4);

      var arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrow.setAttribute('points', tx + ',' + ty + ' ' + p1x + ',' + p1y + ' ' + p2x + ',' + p2y);
      g.appendChild(arrow);

      depArrowOverlay.appendChild(g);
    });
  }

  function renderAllDepArrows() {
    depArrowOverlay.innerHTML = '';
    if (currentView !== 'backlog') return;
    state.issues.forEach(function(issue) {
      drawArrowForIssue(issue);
    });
  }

  function highlightDepArrows(issueId) {
    var id = String(issueId);
    depArrowOverlay.querySelectorAll('g').forEach(function(g) {
      if (g.dataset.targetId === id) {
        g.classList.add('highlighted', g.dataset.inClass);
      } else if (g.dataset.issueId === id) {
        g.classList.add('highlighted', g.dataset.outClass);
      }
    });
  }

  function unhighlightDepArrows() {
    depArrowOverlay.querySelectorAll('g.highlighted').forEach(function(g) {
      g.classList.remove('highlighted', 'in-from-below', 'in-from-above', 'out-up', 'out-down');
    });
  }

  // --- Event listeners ---
  createBtn.addEventListener('click', openCreateModal);
  modalClose.addEventListener('click', closeModal);
  cancelBtn.addEventListener('click', closeModal);
  saveBtn.addEventListener('click', handleSave);
  deleteBtn.addEventListener('click', handleDelete);

  // Clicking outside the modal no longer closes it — use X or Cancel instead

  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') closeModal();
  });

  viewBoardBtn.addEventListener('click', function() { setView('board'); });
  viewBacklogBtn.addEventListener('click', function() { setView('backlog'); });

  searchInput.addEventListener('input', render);

  // Redraw arrows on scroll since they use fixed viewport coordinates
  backlogView.addEventListener('scroll', function() {
    if (currentView === 'backlog') renderAllDepArrows();
  });

  // --- Init ---
  setupDropZones();
  teamCapacityEl.classList.add('active');
  Promise.all([loadState(), loadConfig()]).then(function() { render(); });
})();
</script>
</body>
</html>
